#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <setjmp.h>

jmp_buf env;

void handler(int sig) {
    printf("\n[!] Segmentation fault detected!\n");
    longjmp(env, 1);
}

void verify_overflow(const char* input) {
    char buffer[20];
    int canary = 0xDEADBEEF;
    void* return_addr;
    
    // Get return address - works on both 32 and 64 bit
    #ifdef __x86_64__
        asm volatile(
            "mov 8(%%rbp), %0"
            : "=r"(return_addr)
        );
    #else
        asm volatile(
            "mov 4(%%ebp), %0"
            : "=r"(return_addr)
        );
    #endif

    printf("Initial state:\n");
    printf("Buffer address: %p\n", (void*)buffer);
    printf("Canary address: %p\n", (void*)&canary);
    printf("Return address: %p\n", return_addr);
    printf("Canary value: 0x%08x\n", canary);

    if (!setjmp(env)) {
        printf("\nAttempting buffer operation...\n");
        strcpy(buffer, input);
        
        printf("\nPost-operation state:\n");
        printf("Canary value: 0x%08x\n", canary);
        printf("Buffer contents: ");
        for (int i = 0; i < 20; i++) {
            printf("%02x ", (unsigned char)buffer[i]);
        }
        printf("\n");

        if (canary != 0xDEADBEEF) {
            printf("\n[!] Canary corrupted - Buffer overflow detected!\n");
        }
    }
}

int main(int argc, char* argv[]) {
    signal(SIGSEGV, handler);
    if (argc != 2) {
        printf("Usage: %s <input_string>\n", argv[0]);
        return 1;
    }
    verify_overflow(argv[1]);
    return 0;
}