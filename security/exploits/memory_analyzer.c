#include <stdio.h>
#include <string.h>

void analyze_memory(const char* input) {
    char buffer[20];
    int control_value = 0xDEADBEEF;
    void* stack_ptr;
    
    // Get stack pointer - works on both 32 and 64 bit
    #ifdef __x86_64__
        asm volatile("mov %%rsp, %0" : "=r"(stack_ptr));
    #else
        asm volatile("mov %%esp, %0" : "=r"(stack_ptr));
    #endif

    printf("Before overflow:\n");
    printf("Buffer address: %p\n", (void*)buffer);
    printf("Control value address: %p\n", (void*)&control_value);
    printf("Stack pointer: %p\n", stack_ptr);
    
    // Print initial memory state
    printf("\nInitial buffer contents:");
    for (int i = 0; i < 20; i++) {
        if (i % 8 == 0) printf("\n%p: ", (void*)((char*)buffer + i));
        printf("%02x ", (unsigned char)buffer[i]);
    }
    
    printf("\n\nCopying input...\n");
    strcpy(buffer, input);
    
    printf("\nAfter overflow:\n");
    printf("Buffer contents:");
    for (int i = 0; i < 20; i++) {
        if (i % 8 == 0) printf("\n%p: ", (void*)((char*)buffer + i));
        printf("%02x ", (unsigned char)buffer[i]);
    }
    
    printf("\n\nControl value: 0x%08x\n", control_value);
    if (control_value != 0xDEADBEEF) {
        printf("WARNING: Control value has been modified!\n");
    }
}

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("Usage: %s <input_string>\n", argv[0]);
        return 1;
    }
    analyze_memory(argv[1]);
    return 0;
}