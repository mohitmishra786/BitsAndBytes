#include <stdio.h>
#include <string.h>

void print_stack_frame(void* stack_start, int frame_size) {
    unsigned char* ptr = (unsigned char*)stack_start;
    printf("\nStack Frame Contents:\n");
    for (int i = 0; i < frame_size; i += 16) {
        printf("%p: ", (void*)(ptr + i));
        // Print hex values
        for (int j = 0; j < 16 && (i + j) < frame_size; j++) {
            printf("%02x ", ptr[i + j]);
        }
        // Print ASCII representation
        printf(" |");
        for (int j = 0; j < 16 && (i + j) < frame_size; j++) {
            char c = ptr[i + j];
            printf("%c", (c >= 32 && c <= 126) ? c : '.');
        }
        printf("|\n");
    }
}

void monitor_stack(const char* input) {
    char buffer[20];
    void* stack_ptr;
    void* base_ptr;
    
    // Get stack and base pointers - works on both 32 and 64 bit
    #ifdef __x86_64__
        asm volatile(
            "mov %%rsp, %0\n"
            "mov %%rbp, %1\n"
            : "=r"(stack_ptr), "=r"(base_ptr)
        );
    #else
        asm volatile(
            "mov %%esp, %0\n"
            "mov %%ebp, %1\n"
            : "=r"(stack_ptr), "=r"(base_ptr)
        );
    #endif

    printf("Stack Pointer: %p\n", stack_ptr);
    printf("Base Pointer: %p\n", base_ptr);
    printf("Buffer Address: %p\n", (void*)buffer);

    // Print initial stack state
    printf("\nBefore strcpy:");
    print_stack_frame(stack_ptr, (char*)base_ptr - (char*)stack_ptr + 16);
    
    strcpy(buffer, input);
    
    // Print stack after overflow
    printf("\nAfter strcpy:");
    print_stack_frame(stack_ptr, (char*)base_ptr - (char*)stack_ptr + 16);
}

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("Usage: %s <input_string>\n", argv[0]);
        return 1;
    }
    monitor_stack(argv[1]);
    return 0;
}